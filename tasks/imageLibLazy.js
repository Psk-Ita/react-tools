const fs = require("fs");
const path = require("path");
const glob = require("glob");

const objName = "MyLazyImage";
const cssClassName = "my-lazy-image";
const COMPONENTS_DIR = "src/components/My-Images-Lazy";
const ICONS_SOURCE_DIR = "tasks/image-lib";

try {
    if (fs.existsSync(COMPONENTS_DIR)) {
        glob.sync(`${COMPONENTS_DIR}/**.tsx`).map(fs.unlinkSync)
    } else {
        fs.mkdirSync(COMPONENTS_DIR);
    }
} catch (err) {
    console.error(err);
}

const images = glob.sync(`${ICONS_SOURCE_DIR}/**.+(png|jpeg|jpg|webp)`);
const svgfiles = glob.sync(`${ICONS_SOURCE_DIR}/**.svg`);

const clean = (input) => {
  return input
    .toLowerCase()
    .split("@")[0]
    .replace(/\.| |-/gim, "_");
};

const capitalize = (input) => {
  const segments = input.split("");
  segments[0] = segments[0].toUpperCase();
  return segments.join("");
};

const camelize = (input, escape = 0) => {
  return input
    .split(/\.| |-|@/gim)
    .map((x, idx) => (idx < escape ? x : capitalize(x)))
    .join("");
};

const _options = [];

// for each svg image - write it's related tsx
svgfiles.forEach((svgFile) => {
  const svg = fs.readFileSync(svgFile, "utf8");
  const rawName = path.parse(svgFile).name;
  _options.push(rawName);
  const componentName = camelize(rawName);
  const componentCode = svg
    .replace(/<!--[\s\S\n]*?-->/gim, "")
    .replace(/<\?xml[\s\S\n]*?\?>/gim, "")
    .replace(/<desc>[\s\S\n]*?<\/desc>/gim, "")
    .replace(/<title>[\s\S\n]*?<\/title>/gim, "")
    .replace(">", ` fill='currentColor' focusable='false' {...props} >`)
    .replace(/ class=/gim, " className=")
    .replace(/((\-|\:)+[a-zA-Z]*(=|:))/g, (match) => {
      // camelCase attributes
      const segments = match.split("");
      segments.splice(0, 1);
      return capitalize(segments.join(""));
    })
    .replace(/ style="(.*?)"/g, (match) => {
      // style to react object
      let result = "";
      const tags = match.split("=");
      tags[1]
        .replace(/\"/gim, "")
        .split(";")
        .forEach((attr) => {
          if (attr.length > 0) {
            const def = attr.split(":");
            if (def.length > 1) {
              let value = def[1].trim();
              if (value[value.length - 1] !== "'") {
                value = value + "'";
              }
              if (value[0] !== "'") {
                value = "'" + value;
              }
              result += `${camelize(def[0].trim(), 1)}:${value}, `;
            }
          }
        });
      return ` style={{${result}}}`;
    });
  fs.writeFileSync(
    `${COMPONENTS_DIR}/${componentName}.tsx`,
    `/****************************************************************************************
    DO NOT EDIT THIS FILE
    APPLY YOUR CHANGES TO ${svgFile} FILE, INSTEAD
    THEN RUN npm run image-lib-lazy COMMAND
****************************************************************************************/
        import React from 'react'; export const ${componentName}: React.FC<React.SVGProps<SVGSVGElement>> = (props) => (
            <span role="img" aria-label="${rawName}" className="${cssClassName} ${cssClassName}-${rawName}">
                ${componentCode}
            </span>
        ); export default ${componentName};`
  );
});

images.forEach((image) => {
  const stream = fs.readFileSync(image, "base64");
  const rawName = path.parse(image).name;
  _options.push(rawName);
  const componentName = camelize(rawName);
  const componentCode = `<img alt="" src="data:image/${path
    .extname(image)
    .substring(1)};base64,${stream}" focusable='false' {...props} />`;

  fs.writeFileSync(
    `${COMPONENTS_DIR}/${componentName}.tsx`,
    `/****************************************************************************************
    DO NOT EDIT THIS FILE
    APPLY YOUR CHANGES TO ${image} FILE, INSTEAD
    THEN RUN npm run image-lib-lazy COMMAND
****************************************************************************************/
       import React from 'react'; export const ${componentName}: React.FC<React.SVGProps<HTMLImageElement>> = (props) => (
            <span role="img" aria-label="${rawName}" className="${cssClassName} ${cssClassName}-${rawName}">
                ${componentCode}
            </span>
        ); export default ${componentName};`
  );
});

// create index for svg-images
fs.writeFile(
  `${COMPONENTS_DIR}/index.tsx`,
  `/****************************************************************************************
    DO NOT ADD COMPONENTS IN THIS FILE
    ADD YOUR .SVG IN ${ICONS_SOURCE_DIR} FOLDER
    THEN RUN npm run image-lib-lazy COMMAND
****************************************************************************************/
import React, { Suspense, useCallback, useMemo, ImgHTMLAttributes } from 'react';

//* eslint-disable @typescript-eslint/camelcase */
export enum ${objName}sEnum {
    ${_options.map((x) => `${clean(x)} = "${x}",`).join(`
    `)}
};
//* eslint-enable @typescript-eslint/camelcase */
export interface ${objName}Props extends React.SVGProps<SVGSVGElement | HTMLImageElement> {
    imageId: ${objName}sEnum;
}

export const ${objName} : React.FC<${objName}Props> = (props) => {
    const { imageId, ...oth } = props;

    const capitalize = (input:string): string => {
      const segments = input.split('');
      segments[0] = segments[0].toUpperCase();
      return segments.join('');
    };
    
    const camelize = useCallback((input:string): string => {
      return input
        .split(/\\.| |-|@/gim)
        .map((x) => capitalize(x))
        .join('');
    },[]);
    
    const Image = useMemo(() => React.lazy(() => import(${"`"}./\${camelize(imageId)}${"`"})),[camelize, imageId]);

    return (
      <React.Fragment>
        <Suspense fallback={<span role="img" aria-label="loading" className="${cssClassName} ${cssClassName}-loading"><img alt="loading" src="/loading.gif" {...oth as ImgHTMLAttributes<HTMLImageElement>} />
        </span>}>
          <Image {...oth} />
        </Suspense>
      </React.Fragment>
    );
};`,
  function (err) {
    if (err) return console.log(err);
  }
);

// create test for index
fs.writeFile(
  `${COMPONENTS_DIR}/index.test.tsx`,
  `import { ${objName}, ${objName}sEnum } from './';
import React from "react"; import {act, render} from '@testing-library/react';

const flush = () => act(async() => new Promise((resolve) => setTimeout(resolve, 99)));

describe('${objName}', () => {
  it.each\`
  imageId
      ${_options.map((x) => `\${${objName}sEnum.` + clean(x) + "}").join(`
      `)}
  \`('$imageId should match the snapshot', async({ imageId }) => {
      const {baseElement} = render(<React.Fragment>
              <${objName} id={imageId} imageId={imageId} height={'32px'} width={'32px'} />
          </React.Fragment>);
      await flush();
      expect(baseElement).toMatchSnapshot(imageId);
  });
});
`,
  function (err) {
    if (err) return console.log(err);
  }
);
